---------------------------------Mid Point----------------------------------------------


void midPoint(int h, int k, int r) {
  int x = 0, y = r, d = 1 - r;
  while (x <= y)
  {
    plotCircle(h, k, x, y);
    
    
    if (d < 0)
    {
      d = d + 2 * x + 3;
    }
    else
    {
      d = d + 2 * (x - y) + 5;
      y--;
    }
    x++;
  }
}



-------------------------------Mouse  events--------------------------------

#include <glut.h>
#include <stdio.h>

int ww = 600, wh = 400;
int xi, yi, xf, yf;

void drawLine(GLint x1, GLint y1, GLint x2, GLint y2)
{
	glPointSize(2.0);

	glBegin(GL_POINTS);

	glVertex2i(x1, y1);	//plotting the first point

	GLint y;
	float m = (y2 - y1) / (float)(x2 - x1);
	float c = y1 - x1 * m;
	printf("m = %f   ,    c = %f \n", m, c);

	for (GLint x = x1 + 1; x <= x2; x++) {
		y = m * x + c;
		glVertex2i(x, y);	//plotting points
	}

	glEnd();
}

void display()
{
	drawLine(xi, yi, xf, yf);
	glFlush();
}

void mouse(int btn, int state, int x, int y)
{
	if (btn == GLUT_LEFT_BUTTON)
		if (state == GLUT_DOWN)
		{
			xi = x;
			yi = (wh - y);
		}
		else if (state == GLUT_UP) {
			xf = x;
			yf = (wh - y);
			glutPostRedisplay();
		}
	if (btn == GLUT_RIGHT_BUTTON) {
		glClear(GL_COLOR_BUFFER_BIT);
		glFlush();
	}
}

void myinit()
{
	glViewport(0, 0, ww, wh);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0.0, (GLdouble)ww, 0.0, (GLdouble)wh);
	glMatrixMode(GL_MODELVIEW);

	glClearColor(0.0, 0.0, 1.0, 1.0);
	glColor3f(1.0, 1.0, 0.0);
	glClear(GL_COLOR_BUFFER_BIT);
}

int main(int argc, char** argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowSize(ww, wh);
	glutCreateWindow("Lines");

	glutDisplayFunc(display);
	glutMouseFunc(mouse);
	myinit();
	glutMainLoop();

	return 0;
}


----------------------ColourKeyBoard-----------------------------------------------

#include <glut.h>

float red = 1.0, green = 0.0, blue = 0.0; // Initial color

void display() {
    glClear(GL_COLOR_BUFFER_BIT); 

    glColor3f(red, green, blue); 
    glBegin(GL_QUADS);
        glVertex2f(-0.5, -0.5);
        glVertex2f( 0.5, -0.5);
        glVertex2f( 0.5,  0.5);
        glVertex2f(-0.5,  0.5);
    glEnd();

    glFlush();
}

void keyboard(unsigned char key, int x, int y) {
    if (key == 'r') { red = 1.0; green = 0.0; blue = 0.0; }  // Red
    if (key == 'g') { red = 0.0; green = 1.0; blue = 0.0; }  // Green
    if (key == 'b') { red = 0.0; green = 0.0; blue = 1.0; }  // Blue

    glutPostRedisplay(); // Request to redraw the window
}

int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(500, 500);
    glutCreateWindow("GLUT PostRedisplay Example");

    glutDisplayFunc(display);
    glutKeyboardFunc(keyboard); // Register keyboard callback

    glutMainLoop();
    return 0;
}

--------------------------------BresenhamLine------------------------------------------

#include <glut.h>  
#include <math.h>  
int ww = 600, wh = 400;    
int xi, yi, xf, yf;  

void putPixel (int x, int y)  
{  
   glColor3f (0.3, 0.2, 0.0); // activate the pixel by setting the point color to white  
   glBegin (GL_POINTS);  
   glVertex2i (x, y); // set the point  
   glEnd ();  
   glFlush (); // process all openGL routines as quickly as possible  
} 
 
void display()  
{  
   glClearColor(0.4, 0.7, 0.5, 1.0);  
   glColor3f(0.2, 0.3, 0.3);  
   glClear(GL_COLOR_BUFFER_BIT);  
   glFlush();  
}  
void bresenhamAlg (int x0, int y0, int x1, int y1)  
{  
  int dx = abs (x1 - x0);  
  int dy = abs (y1 - y0);  
  int x, y;  
  if (dx >= dy)  
  {  
   int d = 2*dy-dx;  
   int ds = 2*dy;  
   int dt = 2*(dy-dx);  
       if (x0 < x1)   
       {  
            x = x0;  
            y = y0;  
        }  
        else  
        {   
            x = x1;  
            y = y1;  
            x1 = x0;  
            y1 = y0;  
        }  
  putPixel (x, y);  
  while (x < x1)  
  {  
    if (d < 0)  
        d += ds;  
        else {  
             if (y < y1) {  
               y++;  
               d += dt;  
				}   
             else {  
				y--;  
				d += dt;             
			 }  
		}  
        x++;  
		putPixel (x, y);  
    }  
}  
       else {   
           int d = 2*dx-dy;  
             int ds = 2*dx;  
             int dt = 2*(dx-dy);  
             if (y0 < y1) 
			 {  
				 x = x0;  
				 y = y0;  
             }  
             else 
			 {   
				 x = x1;  
				 y = y1;  
				 y1 = y0;  
				x1 = x0;  
             }  
            putPixel (x, y);   
        while (y < y1)  
        {  
              if (d < 0)  
                 d += ds;  
             else {  
                   if (x < x1)
				   {  
						x++;  
						d += dt;  
					} else 
					{  
						x--;  
						d += dt;  
					}                
				}  
			y++;  
             putPixel (x, y);
			 
       }        
	}  
}  
  

void mouse(int btn, int state, int x, int y)
{
	if (btn == GLUT_LEFT_BUTTON)
		if (state == GLUT_DOWN)
		{
			xi = x;
			yi = (wh - y);
		}
		else if (state == GLUT_UP) {
			xf = x;
			yf = (wh - y);
			glutPostRedisplay();
			bresenhamAlg ( xi, yi, xf, yf);
		}
	if (btn == GLUT_RIGHT_BUTTON) {
		glClear(GL_COLOR_BUFFER_BIT);
		glFlush();
	}
}
void myinit()  
{        
     glViewport(0,0,ww,wh);  
     glMatrixMode(GL_PROJECTION);  
     glLoadIdentity();  
     gluOrtho2D(0.0,(GLdouble)ww,0.0,(GLdouble)wh);  
     glMatrixMode(GL_MODELVIEW);  
}  
int main(int argc, char** argv)  
{  
     glutInit(&argc,argv);  
     glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);  
     glutInitWindowSize(ww,wh);  
     glutCreateWindow("Bresenham Line Algorithm");  
     glutDisplayFunc(display);  
     myinit();  
     glutMouseFunc(mouse);  
     glutMainLoop();  
     return 0;  
}  

-----------------------------------BresenhamCircle-------------------------------

#include <glut.h>
#include <math.h> 

int ww = 800, wh = 600;
int xi, yi, xf, yf; 

void putPixel (int x, int y)  
{  
   glColor3f (0.3, 0.2, 0.0); // activate the pixel by setting the point color to white  
   glBegin (GL_POINTS);  
	glVertex2i (x, y); // set the point  
   glEnd ();  
   glFlush (); // process all openGL routines as quickly as possible  
} 

void plotCircle(int h, int k, int x, int y)
{
	putPixel((x+h), (y+k)); //x,y
	putPixel((y+h), (x+k));//y, x
	putPixel((-y+h), (x+k));//-y, x
	putPixel((-x+h), (y+k));//-x, y
	putPixel((-x+h), (-y+k));//-x,-y
	putPixel((-y+h), (-x+k));//-y,-x
	putPixel((y+h), (-x+k));//y,-x
	putPixel((x+h), (-y+k));//x,-y

}


void display()  
{  
   glClearColor(0.4, 0.7, 0.5, 1.0);  
   glColor3f(0.2, 0.3, 0.3);  
   glClear(GL_COLOR_BUFFER_BIT);  
   glFlush();  
} 

void bresenhamCircle(int h, int k, int r)
{
	int x=0, y=r, d= 3-2*r;
	while(x <= y)
	{
		plotCircle(h, k, x, y);
		if(d<0)
		{
			d = d + 4*x + 6; 
		}
		else
		{
			d = d + 4*(x-y) + 10;
			y--;
		}
		x++;
	}
}

void mouse(int btn, int state, int x, int y)
{
	
	if (btn == GLUT_LEFT_BUTTON)
		if (state == GLUT_DOWN)
		{
			xi = x;
			yi = (wh - y);
		}
		else if (state == GLUT_UP) {
			xf = x;
			yf = (wh - y);
			glutPostRedisplay();
			int r = (int) sqrt((double)(xi-xf)*(xi-xf)+(yi-yf)*(yi-yf));
			bresenhamCircle (xi, yi, r);
		}
	if (btn == GLUT_RIGHT_BUTTON) {
		glClear(GL_COLOR_BUFFER_BIT);
		glFlush();
	}
}




void myinit()  
{        
     glViewport(0,0,ww,wh);  
     glMatrixMode(GL_PROJECTION);  
     glLoadIdentity();  
     gluOrtho2D(0.0,(GLdouble)ww,0.0,(GLdouble)wh);  
     glMatrixMode(GL_MODELVIEW);  
}  
int main(int argc, char** argv)  
{  
     glutInit(&argc,argv);  
     glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);  
     glutInitWindowSize(ww,wh);  
     glutCreateWindow("Bresenham Circle Algorithm");  
     glutDisplayFunc(display);  
     myinit();  
     glutMouseFunc(mouse);  
     glutMainLoop();  
     return 0;  
}

-------------------------------floodfill--------------------------------------
#include <glut.h>
#include <math.h> 
#include <stdio.h>
#include<iostream>
#include <windows.h>

int ww = 800, wh = 600;
int xi, yi, xf, yf, r; 

struct Color 
{
	float r,g,b;
};

struct Color interiorColour={0.0,1.0,0.0};
struct Color fillColour={1.0,1.0,0.0};
struct Color boderColour={0.0,0.0,0.0};

void putPixel (int x, int y)  
{  
   glColor3f (boderColour.r, boderColour.g, boderColour.b);   
   glBegin (GL_POINTS);  
	glVertex2i (x, y); // set the point  
   glEnd ();  
   glFlush (); // process all openGL routines as quickly as possible  
} 

void plotCircle(int h, int k, int x, int y)
{
	putPixel((x+h), (y+k));
	putPixel((y+h), (x+k));
	putPixel((-y+h), (x+k));
	putPixel((-x+h), (y+k));
	putPixel((-x+h), (-y+k));
	putPixel((-y+h), (-x+k));
	putPixel((y+h), (-x+k));
	putPixel((x+h), (-y+k));

}
struct Color getPixelColor(int x, int y) {
	struct Color color;
	glReadPixels(x, y, 1, 1, GL_RGB, GL_FLOAT, &color);
	return color;
}


void setPixelColor(int x, int y,struct Color color) {
  
	glBegin(GL_POINTS);
		glColor3f(color.r, color.g, color.b);
		glVertex2i(x, y);
	glEnd();
	glFlush();
}

void floodFill4(int x, int y,struct Color fill_colour, struct Color old_colour) 
{ 
	struct 	Color color;
	color=getPixelColor(x,y);

	if(color.r==old_colour.r && color.g==old_colour.g && color.b==old_colour.b)
	{
		setPixelColor(x, y, fill_colour);
		floodFill4(x+1, y, fill_colour, old_colour);
		floodFill4(x, y+1, fill_colour, old_colour);
		floodFill4(x-1, y, fill_colour, old_colour);
		floodFill4(x, y-1, fill_colour, old_colour);
	}
} 


void display()  
{  
   glClearColor(interiorColour.r, interiorColour.g, interiorColour.b, 1.0);  
   glColor3f(0.2, 0.3, 0.3);  
   glClear(GL_COLOR_BUFFER_BIT);  

   glFlush();  
} 





void bresenhamCircle(int h, int k, int r)
{
	int x=0, y=r, d= 3-2*r;
	while(x <= y)
	{
		 plotCircle(h, k, x, y);
		if(d<0)
		{
			d = d + 4*x + 6; 
		}
		else
		{
			d = d + 4*(x-y) + 10;
			y--;
		}
		x++;
	}
}

void mouse(int btn, int state, int x, int y)
{
	
	if (btn == GLUT_LEFT_BUTTON)
		if (state == GLUT_DOWN)
		{
			xi = x;
			yi = (wh - y);
		}
		else if (state == GLUT_UP) {
			xf = x;
			yf = (wh - y);
			glutPostRedisplay();
			r = (int) sqrt((double)(xi-xf)*(xi-xf)+(yi-yf)*(yi-yf));
			bresenhamCircle (xi, yi, r);
		}
	if (btn == GLUT_RIGHT_BUTTON) 
	{
		glClear(GL_COLOR_BUFFER_BIT);
		glFlush();
	}
}
void keyboard(unsigned char key, int x, int y)
{
    if (key == 'q' || key == 'Q')
        exit(0);
	else if (key == 'f' || key == 'F')
	{
		glClear(GL_COLOR_BUFFER_BIT);
		bresenhamCircle (xi, yi, r);
		floodFill4(xi,yi, fillColour, interiorColour);
		glFlush();
	}
}


void myinit()  
{        
    glClearColor(1.0,1.0,1.0,0);
  	glColor3f(0.0,0.0,0.0);
  	glPointSize(1.0);
  	glMatrixMode(GL_PROJECTION);
  	glLoadIdentity();
  	gluOrtho2D(0 , ww , 0 , wh);  
}  
int main(int argc, char** argv)  
{  
     glutInit(&argc,argv);  
     glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);  
     glutInitWindowSize(ww,wh);  
     glutCreateWindow("Bresenham Circle Algorithm");  
     glutDisplayFunc(display);  
     myinit();  
     glutMouseFunc(mouse);  
	 glutKeyboardFunc(keyboard);
     glutMainLoop();  
     return 0;  
}

--------------------------------------------CircleFill------------------------------------------------------

#include <glut.h>
#include <math.h> 

int ww = 800, wh = 600;
int xi, yi, xf, yf; 

void putPixel (int x, int y)  
{  
   glColor3f (0.3, 0.2, 0.0); // activate the pixel by setting the point color to white  
   glBegin (GL_POINTS);  
	glVertex2i (x, y); // set the point  
   glEnd ();  
   glFlush (); // process all openGL routines as quickly as possible  
} 

void plotCircle(int h, int k, int x, int y)
{
	putPixel((x+h), (y+k));
	putPixel((y+h), (x+k));
	putPixel((-y+h), (x+k));
	putPixel((-x+h), (y+k));
	putPixel((-x+h), (-y+k));
	putPixel((-y+h), (-x+k));
	putPixel((y+h), (-x+k));
	putPixel((x+h), (-y+k));

}



void display()  
{  
   glClearColor(0.4, 0.7, 0.5, 1.0);  
   glColor3f(0.2, 0.3, 0.3);  
   glClear(GL_COLOR_BUFFER_BIT);  
   glFlush();  
} 

void drawHorizontalLine(int x1,int y1,int x2,int y2)
{	
	glPointSize(2.0);
	glBegin(GL_LINES);
		glVertex2i(x1, y1);
		glVertex2i(x2, y2);
	glEnd();
	glFlush();
}

void horizontalLine(int h, int k, int x, int y)
{
	drawHorizontalLine(-x+h,y+k,x+h,y+k);
	drawHorizontalLine(-y+h,x+k,y+h,x+k);
	drawHorizontalLine(-y+h,-x+k,y+h,-x+k);
	drawHorizontalLine(-x+h,-y+k,x+h,-y+k);
}

void bresenhamCircle(int h, int k, int r)
{
	int x=0, y=r, d= 3-2*r;
	while(x <= y)
	{
		 plotCircle(h, k, x, y);
		horizontalLine(h, k, x, y);
		if(d<0)
		{
			d = d + 4*x + 6; 
		}
		else
		{
			d = d + 4*(x-y) + 10;
			y--;
		}
		x++;
	}
}

void mouse(int btn, int state, int x, int y)
{
	
	if (btn == GLUT_LEFT_BUTTON)
		if (state == GLUT_DOWN)
		{
			xi = x;
			yi = (wh - y);
		}
		else if (state == GLUT_UP) {
			xf = x;
			yf = (wh - y);
			glutPostRedisplay();
			int r = (int) sqrt((double)(xi-xf)*(xi-xf)+(yi-yf)*(yi-yf));
			bresenhamCircle (xi, yi, r);
		}
	if (btn == GLUT_RIGHT_BUTTON) {
		glClear(GL_COLOR_BUFFER_BIT);
		glFlush();
	}
}




void myinit()  
{        
     glViewport(0,0,ww,wh);  
     glMatrixMode(GL_PROJECTION);  
     glLoadIdentity();  
     gluOrtho2D(0.0,(GLdouble)ww,0.0,(GLdouble)wh);  
     glMatrixMode(GL_MODELVIEW);  
}  
int main(int argc, char** argv)  
{  
     glutInit(&argc,argv);  
     glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);  
     glutInitWindowSize(ww,wh);  
     glutCreateWindow("Bresenham Circle Algorithm");  
     glutDisplayFunc(display);  
     myinit();  
     glutMouseFunc(mouse);  
     glutMainLoop();  
     return 0;  
}

---------------------------------------rotation----------------------------------

#define _USE_MATH_DEFINES
#include <glut.h>  
#include <math.h>  
#include <cmath>
#include <iostream>
int ww = 600, wh = 400;  
  
float xi, yi, xf, yf;  
const int rows = 3;
const int NoOfVertices = 4; 
float coordinates [rows][NoOfVertices];

const double pi = M_PI;

void setCoordinates(float x1, float y1, float x2, float y2)
{
	coordinates[0][0]=x1;
	coordinates[1][0]=y1;
	coordinates[2][0]=1;
	coordinates[0][1]=x2;
	coordinates[1][1]=y1;
	coordinates[2][1]=1;
	coordinates[0][2]=x2;
	coordinates[1][2]=y2;
	coordinates[2][2]=1;
	coordinates[0][3]=x1;
	coordinates[1][3]=y2;
	coordinates[2][3]=1;
}
void setRotationMatrx(float teta, float rotationMatrix[rows][rows])
{
	rotationMatrix[0][0]=cos(teta);
	rotationMatrix[0][1]=-1*sin(teta);
	rotationMatrix[0][2]=0;
	rotationMatrix[1][0]=sin(teta);
	rotationMatrix[1][1]=cos(teta);
	rotationMatrix[1][2]=0;
	rotationMatrix[2][0]=0;
	rotationMatrix[2][1]=0;
	rotationMatrix[2][2]=1;
}

void setTranslationMatrix(float dx, float dy, float translationMatrix[rows][rows])
{
	translationMatrix[0][0]=1;
	translationMatrix[0][1]=0;
	translationMatrix[0][2]=dx;
	translationMatrix[1][0]=0;
	translationMatrix[1][1]=1;
	translationMatrix[1][2]=dy;
	translationMatrix[2][0]=0;
	translationMatrix[2][1]=0;
	translationMatrix[2][2]=1;
}
void multiply_arrays(float A[rows][rows], float B[rows][NoOfVertices], float C[rows][NoOfVertices]) 
{
    for (int i = 0; i < rows; i++) 
	{  
        for (int j = 0; j < NoOfVertices; j++) 
		{
            C[i][j] = 0;
            for (int k = 0; k < rows; k++) 
			{
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
}
void putPixel (int x, int y)  
{  
   //glColor3f (0.3, 0.2, 0.0); // activate the pixel by setting the point color to white  
   glBegin (GL_POINTS);  
	   glVertex2i (x, y); // set the point  
	   glEnd ();  
   glFlush (); // process all openGL routines as quickly as possible  
} 
 
void display()  
{  
   glClearColor(0.4, 0.7, 0.5, 1.0);  
   glColor3f(0.2, 0.3, 0.3);  
   glClear(GL_COLOR_BUFFER_BIT);  
   glFlush();  
}  
void bresenhamLine(int x0, int y0, int x1, int y1)  
{  
  int dx = abs (x1 - x0);  
  int dy = abs (y1 - y0);  
  int x, y;  
  if (dx >= dy)  
  {  
   int d = 2*dy-dx;  
   int ds = 2*dy;  
   int dt = 2*(dy-dx);  
       if (x0 < x1)   
       {  
            x = x0;  
            y = y0;  
        }  
        else  
        {   
            x = x1;  
            y = y1;  
            x1 = x0;  
            y1 = y0;  
        }  
	  putPixel (x, y);  
	  while (x < x1)  
	  {  
		if (d < 0)  
			d += ds;  
			else {  
				 if (y < y1) {  
				   y++;  
				   d += dt;  
					}   
				 else {  
					y--;  
					d += dt;             
				 }  
			}  
			x++;  
			putPixel (x, y);  
		}  
	}  
   else 
   {   
	   int d = 2*dx-dy;  
		 int ds = 2*dx;  
		 int dt = 2*(dx-dy);  
		 if (y0 < y1) 
		 {  
			 x = x0;  
			 y = y0;  
		 }  
		 else 
		 {   
			 x = x1;  
			 y = y1;  
			 y1 = y0;  
			 x1 = x0;  
		 }  
		putPixel (x, y);   
		while (y < y1)  
		{  
			  if (d < 0)  
				 d += ds;  
			 else {  
				   if (x > x1)
				   {  
						x--;  
						d += dt;  
					} else 
					{  
						x++;  
						d += dt;  
					}                
				}  
			y++;  
			 putPixel (x, y);
			 
	   }        
	}  
}  

void drawObject(float points[][NoOfVertices])
{
	for(int i=1;i<NoOfVertices;i++)
	{
		bresenhamLine((int) points[0][i-1],(int) points[1][i-1],(int) points[0][i],(int) points[1][i]);
		
	}
	bresenhamLine((int)points[0][0],(int)points[1][0],(int)points[0][NoOfVertices-1],(int)points[1][NoOfVertices-1]);
	glFlush();
	

}
void printArray(int rows, int cols, float arr[][3]) {
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      std::cout << arr[i][j] << " ";
    }
    std::cout << std::endl;
  }
}
void printArray2(int rows, int cols, float arr[][4]) {
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      std::cout << arr[i][j] << " ";
    }
    std::cout << std::endl;
  }
}

void activity()
{
	float degree = 60; 
	float teta  = degree * M_PI / 180;
	float dx=coordinates[0][0];
	float dy=coordinates[1][0];
	float tmatrix [3] [3]; //step 1 matrix
	
	float rmatrix [3] [3]; // //step 2 matrix
	float tmatrix2 [3] [3]; // //step 3 matrix
	setTranslationMatrix(-dx, -dy, tmatrix);
	setRotationMatrx(teta, rmatrix);
	
	setTranslationMatrix(dx, dy, tmatrix2);
	std::cout << " Coordinate matrix" << std::endl;
	printArray2(3,4,coordinates);
	std::cout << " translation matrix" << std::endl;
	printArray(3,3,tmatrix);
	//Start multiplication 
	float temp [3][NoOfVertices]; // to strore results of tmatrix*coordinates 
	multiply_arrays(tmatrix, coordinates, temp);

	float temp2 [3][NoOfVertices]; // to strore results of rmatrix*temp 
	multiply_arrays(rmatrix, temp, temp2);
	float temp3 [3][NoOfVertices]; // to strore results of  rmatrix *temp2 
	multiply_arrays(tmatrix2, temp2, temp3); 
	glColor3f(1.0, 0.0, 0.9);
	drawObject(temp3);
	std::cout << " Results matrix" << std::endl;
	printArray2(3,4,temp3);
	




}
  

void mouse(int btn, int state, int x, int y)
{
	if (btn == GLUT_LEFT_BUTTON)
		if (state == GLUT_DOWN)
		{
			xi = (float)x;
			yi = (float)(wh - y);
		}
		else if (state == GLUT_UP) {
			xf = (float)x;
			yf = (float)(wh - y);
			//glutPostRedisplay();
			setCoordinates(xi, yi, xf, yf);
			drawObject(coordinates);
		}
	if (btn == GLUT_RIGHT_BUTTON) {
		activity();
	}
}
void myinit()  
{        
     glViewport(0,0,ww,wh);  
     glMatrixMode(GL_PROJECTION);  
     glLoadIdentity();  
     gluOrtho2D(0.0,(GLdouble)ww,0.0,(GLdouble)wh);  
     glMatrixMode(GL_MODELVIEW);  
}  
int main(int argc, char** argv)  
{  
     glutInit(&argc,argv);  
     glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);  
     glutInitWindowSize(ww,wh);  
     glutCreateWindow("Bresenham Line Algorithm");  
     glutDisplayFunc(display);  
     myinit();  
     glutMouseFunc(mouse);  
     glutMainLoop();  
     return 0;  
}  


--------------------------------------Clipping--------------------------------

#include <glut.h>  
#include <math.h>  
int ww = 600, wh = 400;    
int xi, yi, xf, yf;  
// Define the region codes
const int INSIDE = 0; // 0000
const int LEFT = 1;   // 0001
const int RIGHT = 2;  // 0010
const int BOTTOM = 4; // 0100
const int TOP = 8;    // 1000

// Define the clipping window
const float xmin = 50, xmax = 250, ymin = 50, ymax = 250;

void putPixel (int x, int y)  
{  
   glColor3f (0.3, 0.2, 0.0); // activate the pixel by setting the point color to white  
   glBegin (GL_POINTS);  
   glVertex2i (x, y); // set the point  
   glEnd ();  
   glFlush (); // process all openGL routines as quickly as possible  
} 

void bresenhamAlg (int x0, int y0, int x1, int y1)  
{  
  int dx = abs (x1 - x0);  
  int dy = abs (y1 - y0);  
  int x, y;  
  if (dx >= dy)  
  {  
   int d = 2*dy-dx;  
   int ds = 2*dy;  
   int dt = 2*(dy-dx);  
       if (x0 < x1)   
       {  
            x = x0;  
            y = y0;  
        }  
        else  
        {   
            x = x1;  
            y = y1;  
            x1 = x0;  
            y1 = y0;  
        }  
  putPixel (x, y);  
  while (x < x1)  
  {  
    if (d < 0)  
        d += ds;  
        else {  
             if (y < y1) {  
               y++;  
               d += dt;  
				}   
             else {  
				y--;  
				d += dt;             
			 }  
		}  
        x++;  
		putPixel (x, y);  
    }  
}  
       else {   
           int d = 2*dx-dy;  
             int ds = 2*dx;  
             int dt = 2*(dx-dy);  
             if (y0 < y1) 
			 {  
				 x = x0;  
				 y = y0;  
             }  
             else 
			 {   
				 x = x1;  
				 y = y1;  
				 y1 = y0;  
				x1 = x0;  
             }  
            putPixel (x, y);   
        while (y < y1)  
        {  
              if (d < 0)  
                 d += ds;  
             else {  
                   if (x < x1)
				   {  
						x++;  
						d += dt;  
					} else 
					{  
						x--;  
						d += dt;  
					}                
				}  
			y++;  
             putPixel (x, y);
			 
       }        
	}  
}  
// Function to compute the region code of a point
int computeOutCode(int x, int y) {
    int code = INSIDE;

    if (x < xmin)
        code |= LEFT;
    else if (x > xmax)
        code |= RIGHT;
    if (y < ymin)
        code |= BOTTOM;
    else if (y > ymax)
        code |= TOP;

    return code;
}
// Function to clip a line using Cohen-Sutherland algorithm
void cohenSutherland(int x0, int y0, int x1, int y1) {
    int outcode0, outcode1, outcode;
    bool accept = false, done = false;

    outcode0 = computeOutCode(x0, y0);
    outcode1 = computeOutCode(x1, y1);

    do {
        if (!(outcode0 | outcode1)) { // Trivially accepted
            accept = true;
            done = true;
        } else if (outcode0 & outcode1) { // Trivially rejected
            done = true;
        } else {
            float x, y;
            outcode = outcode0 ? outcode0 : outcode1;

            if (outcode & TOP) {
                x = x0 + (x1 - x0) * (ymax - y0) / (y1 - y0);
                y = ymax;
            } else if (outcode & BOTTOM) {
                x = x0 + (x1 - x0) * (ymin - y0) / (y1 - y0);
                y = ymin;
            } else if (outcode & RIGHT) {
                y = y0 + (y1 - y0) * (xmax - x0) / (x1 - x0);
                x = xmax;
            } else if (outcode & LEFT) {
                y = y0 + (y1 - y0) * (xmin - x0) / (x1 - x0);
                x = xmin;
            }

            if (outcode == outcode0) {
                x0 = x;
                y0 = y;
                outcode0 = computeOutCode(x0, y0);
            } else {
                x1 = x;
                y1 = y;
                outcode1 = computeOutCode(x1, y1);
            }
        }
    } while (!done);

    if (accept) {
        glColor3f(1.0, 0.0, 0.0);
		bresenhamAlg ( x0,  y0,  x1,  y1);
    }
}

 
void display()  
{  

   glClearColor(0.4, 0.7, 0.5, 1.0);  
   glColor3f(0.2, 0.3, 0.3);  
   glClear(GL_COLOR_BUFFER_BIT);  
   glFlush();  
}  

  

void mouse(int btn, int state, int x, int y)
{
	if (btn == GLUT_LEFT_BUTTON)
		if (state == GLUT_DOWN)
		{
			xi = x;
			yi = (wh - y);
		}
		else if (state == GLUT_UP) {
			xf = x;
			yf = (wh - y);
			glBegin(GL_LINE_LOOP);
			glVertex2f(xmin, ymin);
			glVertex2f(xmax, ymin);
			glVertex2f(xmax, ymax);
			glVertex2f(xmin, ymax);
			glEnd();
			glutPostRedisplay();
			cohenSutherland( xi, yi, xf, yf);
		}
	if (btn == GLUT_RIGHT_BUTTON) {
		glClear(GL_COLOR_BUFFER_BIT);
		glFlush();
	}
}
void myinit()  
{        
     glViewport(0,0,ww,wh);  
     glMatrixMode(GL_PROJECTION);  
     glLoadIdentity();  
     gluOrtho2D(0.0,(GLdouble)ww,0.0,(GLdouble)wh);  
     glMatrixMode(GL_MODELVIEW);  
}  
int main(int argc, char** argv)  
{  
     glutInit(&argc,argv);  
     glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);  
     glutInitWindowSize(ww,wh);  
     glutCreateWindow("Bresenham Line Algorithm");  
     glutDisplayFunc(display);  
     myinit();  
     glutMouseFunc(mouse);  
     glutMainLoop();  
     return 0;  
}  


----------------------------------------------rotationObjet--------------------------

#include <glut.h>
#include <math.h>

float angle = 0;

void display() {
  glClear(GL_COLOR_BUFFER_BIT);
  glPushMatrix();
  glRotatef(angle, 0.0, 0.0, 1.0);
  glBegin(GL_POLYGON);
    glColor3f(1.0, 0.0, 0.0);
    glVertex2f(-0.5, -0.5);
    glVertex2f(-0.5, 0.5);
    glVertex2f(0.5, 0.5);
    glVertex2f(0.5, -0.5);
  glEnd();
  glPopMatrix();
  glutSwapBuffers();
}

void animate(int value) {
  angle += 2.0;
  if (angle > 360) angle -= 360;
  glutPostRedisplay();
  glutTimerFunc(25, animate, value);
}

int main(int argc, char** argv) {
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize(500, 500);
  glutCreateWindow("Rotation Animation");
  glutDisplayFunc(display);
  glutTimerFunc(25, animate, 0);
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);
  glutMainLoop();
  return 0;
}

--------------------------MovingObject--------------------------------------


#include <glut.h>

float x = 0;

void display() {
  glClear(GL_COLOR_BUFFER_BIT);
  glBegin(GL_POLYGON);
    glColor3f(1.0, 0.0, 0.0);
    glVertex2f(x - 0.5, -0.5);
    glVertex2f(x - 0.5, 0.5);
    glVertex2f(x + 0.5, 0.5);
    glVertex2f(x + 0.5, -0.5);
  glEnd();
  glutSwapBuffers();
}

void animate(int value) {
  x += 0.01;
  if (x > 1.5) x = -1.5;
  glutPostRedisplay();
  glutTimerFunc(25, animate, value);
}

int main(int argc, char** argv) {
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize(500, 500);
  glutCreateWindow("Translation Animation");
  glutDisplayFunc(display);
  glutTimerFunc(25, animate, 0);
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho(-1.5, 1.5, -1.0, 1.0, -1.0, 1.0);
  glutMainLoop();
  return 0;
}

-------------------------------------------------------LianBasky--------------------------------------------------------------------------


void liangBasky(int x0, int y0, int x1, int y1) {
	int dx = x1 - x0;
	int dy = y1 - y0;
	float t0 = 0.0;
	float t1 = 1.0;
	
	float p,q,r;

	for(int edge = 0; edge < 4; edge ++ ){
		if(edge == 0){
			p = -dx;
			q = x0 - xmin;
		}else if(edge == 1){
			p = dx;
			q = xmax - x0;
		}else if(edge == 2){
			p = -dy;
			q = y0 - ymin;
		}else {
			p = dy;
			q = ymax-y0;
		}

		r = q/p;

		if(p == 0 && q < 0){
			return;
		}
		
		if (p<0){
			if(r>t1){
				return;
			}else if(r > t0){
				t0 = r;
			}
		}

		else if(p>0){
			if(r<t0){
				return;
			}else if(r<t1){
				t1 = r;
			}
		}
	}

	float x_clipped = x0 + t0*dx;
	float y_clipped = y0 + t0*dy;

	float x_clipped_end = x0 + t1*dx;
	float y_clipped_end = y0 + t1*dy;


	bresenham(x_clipped, y_clipped, x_clipped_end, y_clipped_end, blue);

}

-----------------------------------------------EoC---------------------------------------------------

#include <glut.h>
#include <math.h>
#include <iostream>

using namespace std;


struct Color {
	float r,g,b;
};

struct Color red = {1.0,0.0,0.0};
struct Color green = {0.0,1.0,0.0};
struct Color blue = {0.0,0.0,1.0};
struct Color black = {0.0,0.0,0.0};
struct Color white = {1.0,1.0,1.0};
int xi, yi, xf, yf;
int xmax=500, ymax=500, xmin=100,ymin=100;
int ww = 600;
int wh = 600;
void putPixel(int x, int y, bool isCircle, struct Color color){
	if(!isCircle) {
		float eq = pow((double)(x-300), 2) + pow((double)(y-300),2) - 100*100;
		if(eq <=0){
			glColor3f(red.r, red.g, red.b);
		}else{
			glColor3f(color.r, color.g, color.b);
		}
	}else{
		glColor3f(color.r, color.g, color.b);
	}
	
	glBegin(GL_POINTS);
	glVertex2i(x,y);
	glEnd();
	glFlush();
}


void plotCircle(int h, int k, int x, int y){
	putPixel( x+h, y+k, true, green);
	putPixel(-x+h, -y+k, true, green);

	putPixel(y+h, x+k, true, green);
	putPixel(-y+h, -x+k, true, green);

	putPixel(-x+h, y+k, true, green);
	putPixel(x+h, -y+k, true, green);

	putPixel(y+h, -x+k, true, green);
	putPixel(-y+h, x+k, true, green);
}




void midPoint(int h, int k, int r){
	int x = 0, y=r, d = 1-r;
	while(x<=y){
		plotCircle(h, k, x, y);
		if (d<0){
			d += 2*x + 3;
		}else{
			d += 2*(x-y) + 5;
			y--;
		}
		x++;
	}
}


void bresenham(int x0, int y0, int x1, int y1, struct Color color){
	int dx = abs(x1 - x0);
	int dy = abs(y1- y0);
	int  x, y;
	if(dx >= dy){
		int d = 2*dy - dx;
		int dt = 2*(dy-dx);
		int ds = 2*dy;

		if(x1 < x0){
			x = x1;
			y = y1;
			x1 = x0;
			y1 = y0;
		}else{
			x = x0;
			y= y0;
		}
		putPixel(x,y, false, color);
		while(x<x1){
			if(d < 0){
				d += ds;
			}
			else{
				if(y<y1){
					y++;
					d+=dt;
				}else{
					y--;
					d+=dt;
				}
			}
			x++;
			putPixel(x,y, false, color);

		}
	}else{
		int d = 2*dx - dy;
		int dt = 2*(dx-dy);
		int ds = 2*dx;

		if(y1 < y0){
			x = x1;
			y = y1;
			x1 = x0;
			y1 = y0;
		}else{
			x = x0;
			y= y0;
		}
		putPixel(x,y, false, color);

		while(y<y1){
			if(d<0){
				d+=ds;
			}else{
				if(x<x1){
					x++;
					d+=dt;
				}else{
					x--;

					d+=dt;
				}
			}
			y++;
			putPixel(x,y, false , color);
		}
	}
}

void liangBasky(int x0, int y0, int x1, int y1) {
	int dx = x1 - x0;
	int dy = y1 - y0;
	float t0 = 0.0;
	float t1 = 1.0;
	
	float p,q,r;

	for(int edge = 0; edge < 4; edge ++ ){
		if(edge == 0){
			p = -dx;
			q = x0 - xmin;
		}else if(edge == 1){
			p = dx;
			q = xmax - x0;
		}else if(edge == 2){
			p = -dy;
			q = y0 - ymin;
		}else {
			p = dy;
			q = ymax-y0;
		}

		r = q/p;

		if(p == 0 && q < 0){
			return;
		}
		
		if (p<0){
			if(r>t1){
				return;
			}else if(r > t0){
				t0 = r;
			}
		}

		else if(p>0){
			if(r<t0){
				return;
			}else if(r<t1){
				t1 = r;
			}
		}
	}

	float x_clipped = x0 + t0*dx;
	float y_clipped = y0 + t0*dy;

	float x_clipped_end = x0 + t1*dx;
	float y_clipped_end = y0 + t1*dy;


	bresenham(x_clipped, y_clipped, x_clipped_end, y_clipped_end, blue);

}

void createWindow() {
	bresenham(xmin,ymax,xmax,ymax,black);
	bresenham(xmax,ymax,xmax,ymin, black);
	bresenham(xmax,ymin,xmin,ymin, black);
	bresenham(xmin,ymin,xmin,ymax, black);
}

void mouse(int btn, int state, int x, int y){
	if(btn == GLUT_LEFT_BUTTON){
		if(state == GLUT_DOWN){
			xi = x;
			yi = wh-y;
		}else if(state == GLUT_UP){
			xf = x;
			yf = wh-y;
			liangBasky(xi, yi, xf, yf);
		}

	}
}

void display() {
	 glClearColor(white.r, white.g, white.b, 1.0);  
	 glClear(GL_COLOR_BUFFER_BIT);  
	 midPoint(300,300,100);
	 createWindow();
	 glFlush(); 
}

void init(){
	 glViewport(0,0,ww,wh);  
     glMatrixMode(GL_PROJECTION);  
     glLoadIdentity();  
     gluOrtho2D(0.0,(GLdouble)ww,0.0,(GLdouble)wh);  
     glMatrixMode(GL_MODELVIEW);  
}



int main(int argc, char ** argv){
	glutInit(&argc,argv);  
     glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);  
     glutInitWindowSize(ww,wh);  
     glutCreateWindow("2022 end");  
     glutDisplayFunc(display);  
     init();  
     glutMouseFunc(mouse);  
     glutMainLoop();  
     return 0;  
}



---------------------------------------------------------ICA-------------------------------------------------------------

#define _USE_MATH_DEFINES
#include "glut.h"
#include "iostream"
#include "math.h"

using namespace std;
//float degree;

struct Color {
  float r, g, b;
};

Color lineColor   = {1.0,0.0,0.0 };
Color circleColor = {0.0,1.0,0.0 };
Color bgColor     = {0.5,0.5,0.5 };
Color fillColor   = {0.0,0.0,1.0 };

int ww = 800, wh = 600;
int xi, yi, xf, yf;
int radius = 100;
bool show = false , rightClicked = false;
const float degree = 60 * (M_PI / 180.0);
//float degree = 60 * (3.1415 / 180.0);



void putPixel(Color color, int x, int y)
{
  glColor3f(color.r, color.g, color.b);
  glBegin(GL_POINTS);
  glVertex2i(x, y);
  glEnd();
  //glFlush();
}

Color getPixelColor(int x, int y) {
  Color color;
  glReadPixels(x, y, 1, 1, GL_RGB, GL_FLOAT, &color);
  return color;
}

void putPixelCircle(Color color, int x, int y) {
   float eq = pow(x - xi, (double) 2) + pow(y - yi, (double)2) - pow(radius,(double) 2);
    if (eq <= 0) {
        glColor3f(color.r, color.g, color.b);
        glBegin(GL_POINTS);
        glVertex2i(x, y);
        glEnd();
    }
}
/*void putPixelCircle(Color color, int x, int y) {
  glColor3f(color.r, color.g, color.b);
  glBegin(GL_POINTS);
  float eq = pow((double)(x - xi), 2) + pow((double)(y - yi), 2) - pow((double)radius,2);
  if (eq <= 0) {
    glVertex2i(x, y);
  }
  glEnd();
  //glFlush();
}
*/

void plotCircle(int h, int k, int x, int y)
{
  putPixelCircle(circleColor,(x + h), (y + k));
  putPixelCircle(circleColor,(y + h), (x + k));
  putPixelCircle(circleColor,(-y + h), (x + k));
  putPixelCircle(circleColor,(-x + h), (y + k));
  putPixelCircle(circleColor,(-x + h), (-y + k));
  putPixelCircle(circleColor,(-y + h), (-x + k));
  putPixelCircle(circleColor,(y + h), (-x + k));
  putPixelCircle(circleColor,(x + h), (-y + k));

}

void init() {
  glViewport(0, 0, ww, wh);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluOrtho2D(0.0, (GLdouble)ww, 0.0, (GLdouble)wh);
  glMatrixMode(GL_MODELVIEW);
}

void DDA(Color color, int x1, int y1, int x2, int y2) {
  int dx = x2 - x1, dy = y2 - y1, steps, k;
  float x, y;
  float xincrement, yincrement;
  x = x1;
  y = y1;

  if (abs(dx) > abs(dy)) {
    steps = abs(dx);
  }
  else {
    steps = abs(dy);
  }
  xincrement = dx / (float)steps;
  yincrement = dy / (float)steps;

  putPixel(color, (int)x, (int)y);


  for (k = 0; k < steps; k++) {

    x += xincrement;
    y += yincrement;
    putPixel(color, (int)x, (int)y);
  }
}

void midPoint(int h, int k, int r) {
  int x = 0, y = r, d = 1 - r;
  while (x <= y)
  {
    plotCircle(h, k, x, y);
    
    
    if (d < 0)
    {
      d = d + 2 * x + 3;
    }
    else
    {
      d = d + 2 * (x - y) + 5;
      y--;
    }
    x++;
  }
}



void drawHexagon(int x, int y) {
  DDA(lineColor,x - radius, y, x - (radius - radius * cos(degree)), y + radius * sin(degree));
  DDA(lineColor, x - (radius - radius * cos(degree)), y + radius * sin(degree),x + (radius - radius * cos(degree)), y + radius * sin(degree));
  DDA(lineColor, x + (radius - radius * cos(degree)), y + radius * sin(degree), x + radius, y);
  DDA(lineColor, x + radius, y,x + (radius - radius * cos(degree)), y - radius * sin(degree));
  DDA(lineColor, x + (radius - radius * cos(degree)), y - radius * sin(degree), x - (radius - radius * cos(degree)), y - radius * sin(degree));
  DDA(lineColor, x - (radius - radius * cos(degree)), y - radius * sin(degree), x - radius, y);
  DDA(lineColor, x - radius, y, x - (radius - radius * cos(degree)), y + radius * sin(degree));
}

void createHalfCircles(int x, int y) {
  midPoint(x-radius, y, radius);
  midPoint(x - (radius - radius * cos(degree)), y+radius * sin(degree), radius);
  midPoint(x + (radius - radius * cos(degree)), y+ radius * sin(degree), radius);
  midPoint(x + radius, y, radius);
  midPoint(x + (radius - radius * cos(degree)), y- radius * sin(degree), radius);
  midPoint(x - (radius - radius * cos(degree)), y- radius * sin(degree), radius);
}

int quarterCircle(int cx, int cy, int val, int side, int type) {
  int d;
  int x;
  if (type == 0) {
    d = pow((double)radius,2) - pow((double)(val - cy), 2);
    if (side == 0) {
      x = cx - sqrt((double)d);
    }
    else {
      x = cx + sqrt((double)d);
    }
  }
  else {
    d = pow((double)radius, 2) - pow((double)(val - cx), 2);
    if (side == 0) {
      x = cy - sqrt((double)d);
    }
    else {
      x = cy + sqrt((double)d);
    }
  }
  
  return x;
}

void filling() {

for (int y = yi - radius * sin(degree); y <= yi; y++) {
    int x1 = quarterCircle(xi-radius, yi, y, 1, 0);
    int x2 = quarterCircle(xi + (radius - radius * cos(degree)), yi - radius * sin(degree), y, 0, 0);
    DDA(fillColor, x1, y, x2, y);
  }

  for (int y = yi - radius * sin(degree); y <= yi; y++) {
    int x1 = quarterCircle(xi + radius, yi, y, 0, 0);
    int x2 = quarterCircle(xi - (radius - radius * cos(degree)), yi - radius * sin(degree), y, 1, 0);
    DDA(fillColor, x1, y, x2, y);
  }


  for (int y = yi + radius * sin(degree); y > yi; y--) {
    int x1 = quarterCircle(xi - (radius - radius * cos(degree)), yi + radius * sin(degree), y, 1, 0);
    int x2 = quarterCircle(xi + radius, yi, y, 0, 0);
    DDA(fillColor, x1, y, x2, y);
  }

  for (int y = yi + radius * sin(degree); y > yi; y--) {
    int x1 = quarterCircle(xi + (radius - radius * cos(degree)), yi + radius * sin(degree), y, 0, 0);
    int x2 = quarterCircle(xi - radius, yi, y, 1, 0);
    DDA(fillColor, x1, y, x2, y);
  }

  for (int x = xi; x < xi + radius; x++) {
    int y1 = quarterCircle(xi + (radius - radius * cos(degree)), yi + radius * sin(degree), x, 0, 1);
    int y2 = quarterCircle(xi + (radius - radius * cos(degree)), yi - radius * sin(degree), x, 1, 1);
    DDA(fillColor, x, y1, x, y2);
  }

  for (int x = xi; x >= xi - radius; x--) {
    int y1 = quarterCircle(xi - (radius - radius * cos(degree)), yi + radius * sin(degree), x, 0, 1);
    int y2 = quarterCircle(xi - (radius - radius * cos(degree)), yi - radius * sin(degree), x, 1, 1);
    DDA(fillColor, x, y1, x, y2);
  }

}




void display()
{
  glClearColor(bgColor.r, bgColor.g, bgColor.b, 1.0);
  glColor3f(bgColor.r, bgColor.g, bgColor.b);
  glClear(GL_COLOR_BUFFER_BIT);
  if (show) {
    drawHexagon(xi, yi);
    createHalfCircles(xi, yi);
    if (rightClicked) {
      filling();
    }
  }
    
  glFlush();
}


void mouse(int btn, int state, int x, int y)
{

  if (btn == GLUT_LEFT_BUTTON)
  {
    if (state == GLUT_DOWN) {
      xi = x;
      yi = wh - y;
    }
    else if (state == GLUT_UP) {
      xf = x;
      yf = (wh - y);
      glutPostRedisplay();
      radius = (int)sqrt((double)(xi - xf) * (xi - xf) + (yi - yf) * (yi - yf));
      show = true;
      rightClicked = false;
    }

  }
  if (btn == GLUT_RIGHT_BUTTON) {
    if(state == GLUT_DOWN){
      glClear(GL_COLOR_BUFFER_BIT);
      rightClicked = true;
      glutPostRedisplay();
      glFlush();
    }
  }
}


int main(int argc, char** argv) {
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
  glutInitWindowSize(ww, wh);
  glutCreateWindow("Practical ICA");
  glutDisplayFunc(display);
  init();
  glutMouseFunc(mouse);
  glutMainLoop();

  return 0;

}
------------------------------------2021EoC-----------------------------------------------------
#include <glut.h>
#include <math.h> 

int ww = 800, wh = 600;
int xi, yi, xf, yf;

struct Color
{
	float r, g, b;
};
struct Color fillColour = { 0.0,0.0,1.0 };
struct Color c1 = { 1.0,0.0,0.0 };
struct Color c2 = { 0.0,1.0,0.0 };

struct Color getPixelColor(int x, int y) {
	struct Color color;
	glReadPixels(x, y, 1, 1, GL_RGB, GL_FLOAT, &color);
	return color;
}

void putPixel1(struct Color color, int x, int y)
{
	struct 	Color color1;
	color1 = getPixelColor(x, y);

	glColor3f(color.r, color.g, color.b); // activate the pixel by setting the point color to white  
	glBegin(GL_POINTS);
	if (color1.b == fillColour.b && color1.g == fillColour.g && color1.r == fillColour.r) {
		glVertex2i(x, y);
	}// set the point  
	glEnd();
	glFlush();
	
}
void putPixel(struct Color color, int x, int y)
{
	struct 	Color color1;
	color1 = getPixelColor(x, y);

	glColor3f(color.r, color.g, color.b); // activate the pixel by setting the point color to white  
	glBegin(GL_POINTS);
	glVertex2i(x, y);// set the point  
	glEnd();
	glFlush();
	// process all openGL routines as quickly as possible  
}

void plotCircle(struct Color color, int h, int k, int x, int y)
{
	putPixel(color, (x + h), (y + k));
	putPixel(color, (y + h), (x + k));
	putPixel(color, (-y + h), (x + k));
	putPixel(color, (-x + h), (y + k));
	putPixel(color, (-x + h), (-y + k));
	putPixel(color, (-y + h), (-x + k));
	putPixel(color, (y + h), (-x + k));
	putPixel(color, (x + h), (-y + k));

}void plotCircle1(struct Color color, int h, int k, int x, int y)
{
	putPixel1(color, (x + h), (y + k));
	putPixel1(color, (y + h), (x + k));
	putPixel1(color, (-y + h), (x + k));
	putPixel1(color, (-x + h), (y + k));
	putPixel1(color, (-x + h), (-y + k));
	putPixel1(color, (-y + h), (-x + k));
	putPixel1(color, (y + h), (-x + k));
	putPixel1(color, (x + h), (-y + k));

}




void display()
{
	glClearColor(0.4, 0.7, 0.5, 1.0);
	glColor3f(0.2, 0.3, 0.3);
	glClear(GL_COLOR_BUFFER_BIT);
	glFlush();
}

/*void drawHorizontalLine(int x1,int y1,int x2,int y2)
{
	glPointSize(2.0);
	glBegin(GL_LINES);
		glVertex2i(x1, y1);
		glVertex2i(x2, y2);
	glEnd();
	glFlush();
}*/

void bresenhamAlg(struct Color fill_color, int x0, int y0, int x1, int y1)
{
	int dx = abs(x1 - x0);
	int dy = abs(y1 - y0);
	int x, y;
	if (dx >= dy)
	{
		int d = 2 * dy - dx;
		int ds = 2 * dy;
		int dt = 2 * (dy - dx);
		if (x0 < x1)
		{
			x = x0;
			y = y0;
		}
		else
		{
			x = x1;
			y = y1;
			x1 = x0;
			y1 = y0;
		}
		putPixel(fill_color, x, y);
		while (x < x1)
		{
			if (d < 0)
				d += ds;
			else {
				if (y < y1) {
					y++;
					d += dt;
				}
				else {
					y--;
					d += dt;
				}
			}
			x++;
			putPixel(fill_color, x, y);
		}
	}
	else {
		int d = 2 * dx - dy;
		int ds = 2 * dx;
		int dt = 2 * (dx - dy);
		if (y0 < y1)
		{
			x = x0;
			y = y0;
		}
		else
		{
			x = x1;
			y = y1;
			y1 = y0;
			x1 = x0;
		}
		putPixel(fill_color, x, y);
		while (y < y1)
		{
			if (d < 0)
				d += ds;
			else {
				if (x < x1)
				{
					x++;
					d += dt;
				}
				else
				{
					x--;
					d += dt;
				}
			}
			y++;
			putPixel(fill_color, x, y);

		}
	}
}

void horizontalLine(struct Color color, int h, int k, int x, int y)
{
	bresenhamAlg(color, -x + h, y + k, x + h, y + k);
	bresenhamAlg(color, -y + h, x + k, y + h, x + k);
	bresenhamAlg(color, -y + h, -x + k, y + h, -x + k);
	bresenhamAlg(color, -x + h, -y + k, x + h, -y + k);
}

void midPoint(int h, int k, int r)
{
	int x = 0, y = r, d = 1 - r;
	while (x <= y)
	{
		plotCircle(fillColour, h, k, x, y);
		horizontalLine(fillColour, h, k, x, y);
		if (d < 0)
		{
			d = d + 2 * x + 3;
		}
		else
		{
			d = d + 2 * (x - y) + 5;
			y--;
		}
		x++;
	}
}



void halfCircle(struct Color fill_color, int h, int k, int r) {



	int x = 0, y = r, d = 1 - r;
	while (x <= y)
	{


		plotCircle1(fill_color, h, k, x, y);

		if (d < 0)
		{
			d = d + 2 * x + 3;
		}
		else
		{
			d = d + 2 * (x - y) + 5;
			y--;
		}
		x++;
	}

}









void mouse(int btn, int state, int x, int y)
{

	if (btn == GLUT_LEFT_BUTTON)
		if (state == GLUT_DOWN)
		{
			xi = x;
			yi = (wh - y);
		}
		else if (state == GLUT_UP) {
			xf = x;
			yf = (wh - y);
			glutPostRedisplay();
			int r = (int)sqrt((double)(xi - xf) * (xi - xf) + (yi - yf) * (yi - yf));
			midPoint(400, 400, 100);
			halfCircle(c1, 500, 400, 100);
			halfCircle(c2, 300, 400, 100);

			halfCircle(c2, 450, 486, 100);
			halfCircle(c1, 350, 314, 100);

			halfCircle(c1, 350, 486, 100);
			halfCircle(c2, 450, 314, 100);
		}
	if (btn == GLUT_RIGHT_BUTTON) {
		glClear(GL_COLOR_BUFFER_BIT);
		glFlush();
	}
}





void myinit()
{
	glViewport(0, 0, ww, wh);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0.0, (GLdouble)ww, 0.0, (GLdouble)wh);
	glMatrixMode(GL_MODELVIEW);
}
int main(int argc, char** argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowSize(ww, wh);
	glutCreateWindow("Bresenham Circle Algorithm");
	glutDisplayFunc(display);
	myinit();
	glutMouseFunc(mouse);
	glutMainLoop();
	return 0;
}

----------------------------------------------------------------------------------------

composer create-project laravel/laravel name

php artisan serve

php artisan migrate

php artisan make:migration create_products_table

php artisan migrate 

php artisan make:model product


---------------------------------------------------------------------------------------------------------


// Database

public function up(): void
    {
        Schema::create('products', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->integer('qty');
            $table->decimal('price');
            $table->text('description');
            $table->timestamps();
        });
    }
	
//Models:

//product

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Product extends Model
{
    protected $fillable = [
        'name',
        'qty',
        'price',
        'description'
    ];
}


//authController

<?php

namespace App\Http\Controllers;

use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;

class authController extends Controller
{

    public function index() {

        return view('welcome');
    }
    public function registerPage() {
        return view('auth.register');
    }

    public function register(Request $request) {
        $password1 = $request -> input('password');
        $password2 = $request -> input('password2');

        if($password1 != $password2){
            return redirect(route('user.register')) -> with('error' , "password not matched");

        }

        $data = $request->validate([
            "name" => "required",
            "email" => "required|email|",
            "password" => "required" 
        ]);

        $data['password'] = Hash::make($data['password']);
 
        $user = User::create($data);
        return redirect(route('user.login'));
    }

    public function loginPage(){

        return view('auth.login'); 
    }


    public function login(Request $request){
        $credentials = $request -> validate([
            'email' => 'required|email',
            "password" => 'required'
        ]);

        if(Auth::attempt($credentials)){
            $request->session()->regenerate();
            return redirect(route('index'));
        }

        return redirect()->back()->with('error' , 'email or password incorrect');
        //
    }

    public function logout(Request $request){
        Auth::logout();
        $request->session()->invalidate();
        $request->session()->regenerateToken();

        return redirect() -> route('user.login');
    } 

    public function resetPass(){
        return view('auth.passreset');
    }

    public function reset(Request $request){
        $email = Auth::user()->email;
        $user = User::where('email', $email)->first();
        if(Auth::attempt(['email'=>$email, 'password'=>$request->input('prePassword')])){
            if($request->input('password') == $request->input('password2')){
                $user->password = Hash::make($request->input('password2'));
                $user->save();
                return redirect()->route('login');
            }
            return redirect()->back()->with('error', 'password not matches');
        }
        return redirect()->back()->with('error', 'token not set');

    }
}


//Views:

//login

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <div>Login page</div><br>
    <form action="{{route('login')}}" method="post">
        @csrf
        <div>
            <input type="text" name="email" id="" placeholder="email">
        </div>
        <div>
            <input type="password" name="password" id="" placeholder="password">
        </div>
        <div>
            <input type="submit" value="login">
        </div>
    </form>
    <br><br>
    @if (session()->has('error'))
        <div>{{session('error')}}</div>
    @endif
    <br><br>
    <p>if you don't have an account? please <a href="/register">register</a></p>
</body>
</html>


//passreset

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <div>Login page</div><br>
    <form action="{{route('login')}}" method="post">
        @csrf
        <div>
            <input type="text" name="email" id="" placeholder="email">
        </div>
        <div>
            <input type="password" name="password" id="" placeholder="password">
        </div>
        <div>
            <input type="submit" value="login">
        </div>
    </form>
    <br><br>
    @if (session()->has('error'))
        <div>{{session('error')}}</div>
    @endif
    <br><br>
    <p>if you don't have an account? please <a href="/register">register</a></p>
</body>
</html>


//register

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <div>
        Register web application
    </div>
    <br>
    <form action="{{route('register')}}" method="post">
        @csrf
        <div>
            <input type="text" name="name" id="" placeholder="name">
        </div>
        <div>
            <input type="text" name="email" id="" placeholder="email">
        </div>
        <div>
            <input type="password" name="password" id="" placeholder="password">
        </div>
        <div>
            <input type="password" name="password2" id="" placeholder="re-type password" />
        </div>
        <div>
            <input type="submit" value="register">
        </div>
    </form>

    <br><br>
        <div>
            @if (session() -> has('error'))
                <div>{{session('error')}}</div>
            @endif
        </div>
    <br><br>
    <p>if you alread have an account: <a href="/login">login</a></p>
</body>
</html>


//web

<?php

use App\Http\Controllers\authController;
use Illuminate\Support\Facades\Route;

/*
|--------------------------------------------------------------------------
| Web Routes
|--------------------------------------------------------------------------
|
| Here is where you can register web routes for your application. These
| routes are loaded by the RouteServiceProvider within a group which
| contains the "web" middleware group. Now create something great!
|
*/

Route::get('/', [authController::class, 'index'])->name('index');

Route::get('/register', [authController::class ,'registerPage']) -> name('user.register');
Route::post('/register', [authController::class, 'register']) -> name('register'); 

Route::get('/login', [authController::class, 'loginPage']) -> name('user.login');
Route::post('/login', [authController::class, 'login']) -> name('login');

Route::post('/logout', [authController::class, 'logout']) -> name('user.logout');
Route::post('/reset', [authController::class, 'reset']) -> name('reset');

Route::get('/resetPass', [authController::class,'resetPass']) -> name('reset.pass');


//channels

Broadcast::channel('App.Models.User.{id}', function ($user, $id) {
    return (int) $user->id === (int) $id;
});


//api

Route::middleware('auth:sanctum')->get('/user', function (Request $request) {
    return $request->user();
});

