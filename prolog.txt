likes(alice, apple).
likes(bob, banana).
likes(charlie, apple).

% 1. Who likes the same fruit as someone else? (using unification)
same_taste(Person1, Person2) :-
    likes(Person1, Fruit),
    likes(Person2, Fruit),
    Person1 \= Person2.  % Not the same person (unifiable but different)

% 2. Check if two people like the same fruit but are the same person (demonstrate ==)
same_person_same_taste(Person1, Person2) :-
    likes(Person1, Fruit),
    likes(Person2, Fruit),
    Person1 == Person2.  % Strict identity

% 3. Fail when comparing with \== (not strictly identical)
different_individuals(Person1, Person2) :-
    Person1 \== Person2.

% 4. Assign fruit to person if not already matched (using =)
match_fruit(Person, Fruit) :-
    likes(Person, F),
    Fruit = F.  % Unification assigns Fruit to matched value



% Query Alice and Charlie both like apple, and they are not the same person.
same_taste(alice, charlie).
true.
% Uses == to check for identity.
same_person_same_taste(alice, alice).
% Although they like the same fruit, alice \== charlie, so this fails.
same_person_same_taste(alice, charlie).
false.
% Uses \== to check theyâ€™re not the same exact person.
different_individuals(bob, charlie).



==========================================================================================

salary(john, 50000).
salary(mary, 65000).
salary(raj, 30000).

bonus(Employee, Bonus) :-
    salary(Employee, Salary),
    Bonus is Salary * 0.10.

same_salary(E1, E2) :-
    salary(E1, S1),
    salary(E2, S2),
    S1 =:= S2.

earns_more_than(Employee, Threshold) :-
    salary(Employee, Salary),
    Salary > Threshold.

earns_less_or_equal(Employee, Limit) :-
    salary(Employee, Salary),
    Salary =< Limit.

salary_different(E1, E2) :-
    salary(E1, S1),
    salary(E2, S2),
    S1 =\= S2.


==========================================================================================

known_person(alice).
known_person(bob).

greet_user :-
    write('What is your name? '), nl,
    read(Name),
    write('Hello, '), write(Name), write('!'), nl.

age_response :-
    write('Enter your age: '), nl,
    read(Age),
    Age >= 18 ->
        write('You are an adult.'), nl ;
        write('You are a minor.'), nl.

interact :-
    write('Please enter your name: '), nl,
    read(Name),
    write('Hi '), write(Name), write(', how old are you?'), nl,
    read(Age),
    write('You are '), write(Age), write(' years old.'), nl.


==========================================================================================



test_term(john).           % atom
test_term(42).             % integer
test_term(3.14).           % float
test_term(X).              % variable (unbound)
test_term(name(john)).     % compound term

check_atom(X) :-
    atom(X),
    write(X), write(' is an atom.'), nl.

check_number(X) :-
    number(X),
    write(X), write(' is a number.'), nl.

check_integer(X) :-
    integer(X),
    write(X), write(' is an integer.'), nl.

check_float(X) :-
    float(X),
    write(X), write(' is a float.'), nl.

check_variable(X) :-
    var(X),
    write('The term is a variable.'), nl.

check_nonvar(X) :-
    nonvar(X),
    write(X), write(' is not a variable.'), nl.

check_compound(X) :-
    compound(X),
    write(X), write(' is a compound term.'), nl.


==========================================================================================

marks(john, 80, 90, 70).
marks(mary, 75, 85, 95).
marks(alan, 60, 50, 40).

total_marks(Student, Total) :-
    marks(Student, M1, M2, M3),
    Total is M1 + M2 + M3.

average_marks(Student, Average) :-
    marks(Student, M1, M2, M3),
    Total is M1 + M2 + M3,
    Average is Total / 3.

==========================================================================================

% Facts
parent(john, mary).
parent(john, sam).
parent(mary, alice).
parent(sam, bob).

% Rules
grandparent(X, Y) :- parent(X, Z), parent(Z, Y).

%Query
grandparent(john, bob).

==========================================================================================


% Base case: Element is at the head (position 1)
index_of(Element, [Element | _], 1).

% Recursive case: Element is not at the head, check tail
index_of(Element, [_ | Tail], Index) :-
    index_of(Element, Tail, Index1),
    Index is Index1 + 1.


========================================================================================

% Base case: The length of an empty list is 0
list_length([], 0).

% Recursive case: count head, then recurse on the tail
list_length([_ | Tail], Length) :-
    list_length(Tail, TailLength),
    Length is TailLength + 1.

=========================================================================================

% Base case: Only one element, it's the maximum
max_in_list([X], X).

% Recursive case: Compare head with max of tail
max_in_list([H | T], Max) :-
    max_in_list(T, MaxTail),
    ( H >= MaxTail -> Max = H ; Max = MaxTail ).






